---
date: 21:27 2015/3/12
title: SICP第一章笔记
layout: post
tag:
  - SICP
  - lisp
---

2015.03.12  
开始读SICP了嗯。  
虽然只看了第一章但是函数式编程真是奇妙。  
已经感受到了lisp的神奇之处了。
  

2015.04.23   
回头看看一个多月前写的东西决定还是重新整理丰富一下比较好……  

---

###程序

>每一种强力的语言都提供了三种机制：

> - *基本表达形式* ，用于表示语言所关心的最简单的个体  
> - *组合的方法*，通过它们可以从简单的东西出发构造复杂的元素  
> - *抽象的方法*，通过它们可以为复合对象命名，并将它们当做单元去操作  

程序设计中需要处理两类要素：过程和数据（实际上并不严格区分）  
基本的数据和基本的过程，以及对过程和数据抽象和组合的方法  

###表达式  

scheme使用前缀表达式，如：  
```
	(+ (* 3 5) (- 10 6))
```
###define

define是最简单的抽象方法。  
定义变量：   
```
	(define pi 3.141159)    
```	  
定义过程：  
```
	(define (square x) (* x x))  
```
###条件表达式   

```
(define (abs x)
	(cond ((> x 0) x)
		  ((= x 0) 0)
		  ((< x 0) (-x))))

(define (abs x)
	(if (< x 0)
		(-x)
		x))
```
		
### 逻辑复合运算符
仍然是前缀表达式写法，不禁想起了<html><del>天国的</del></html>logo语言。  
刚开始学C的时候某老师似乎就说过logo的逻辑运算前缀写法比较奇葩，
一般都是中缀。当时并不以为意，最近才看到原来logo是lisp的一种方言。  
<html>
<del>从那么小开始就接触函数式编程的我如今找不到工作怎么想都是世界的错</del>
<html>  

```
(and (> x 5) (< x 10))
(or (> x y) (= x y))
```

### 黑箱
>过程定义应该能隐藏一些细节。
>用户在使用一个时应该不需要去弄清如何实现。   

###过程作为参数/作为返回值
```
(define (sum term a next b)
	(if (> a b)
		0
		(+	(term a)
			(sum term (next a) next b))))

(define (inc n) (+ n 1))

(define (cube n) (* n n n))

(define (sum-cubes a b)
	(sum cube a inc b)

(sum-cube 1 10)
55
```
过程inc过程就是简单的自增，cube则是单纯计算立方。  
而过程sum-cubes将cube作为参数term，inc作为参数next传给了sum。  
可以看到sum中累加了term处理a得到的值，
并用inc作为a在递归过程中变化的规则。  
可以说sum-cubes 是sum的一个实例，
实例化的部分就是*累加值的计算规则*和*自变量递进的计算规则*  
这两个规则就是sum接收到的两个过程，cube和inc  
当然，sum-cubes这个实例同样是过程，而不是表达式或数值。  

### lamda构造过程
如上例中sum-cubes可以写作
```
(define (sum-cubes a b)
	(sum (lambda (x) (* x x x)) a (lambda (x) (+ x 1)) b))
```
即直接用(lambda (x) (+ x 1))来代替inc。  
也就是说lambda可以直接构造过程。  
顺便，lambda构造的过程可用于组合式的运算符，如：
```
((lambda (x y z) (+ x y (square z))) 1 2 3)
12
```
仍然是前缀表达式结果。  


##环境与组合式   
>实际上，构造一个复杂的程序，也就是为了去一步步地创建出越来越复杂的计算性对象。
>解释器使这种逐步的程序构造过程变得非常方便，因为我们可以通过一系列交互式动作，逐步创建起所需要的名字-对象关联。
>这种特征鼓励人们采用递增的方式去开发和调试程序。
>在很大程度上，这一情况也处于另一个事实，那就是，一个Lisp程序通常总是由一大批相对简单的过程组成的。    
>应该看到，我们可以将值与符号关联，而后又能提取处这些值，这意味着解释器必须维护某种存储能力，以便保持有关的名字-值对偶的轨迹。
>这种存储被称为环境。

lisp给我最大的冲击就是他的规则。Lisp的语法非常简单，
好像是在鼓励使用者自己从头实现包括乘除和乘方开方在内的表达式和函数，
甚至有种想只给加号，让使用者从减号开始从头定义整个数学规则的感觉。  
事实上，这一节的示例代码正是在实现平方和绝对值。   
从学习的角度来说，lisp给我一种图灵机的感觉：
仅仅给出最简单最基本但是在数学上完备的规则，
但是又能从简陋的规则上一点一点构建起庞大的运算法则。   
可是看到后来又发现，
define实在太强大（或者说除了define和lambda等等使用者几乎没有其他可以玩的花样了），
以至于简直可以把lisp代码写的比任何一种编程语言都像自然语言。  
简直辩证统一……

##将过程作为参数
>人们对于功能强大的程序设计语言有一个必然要求，
就是能为公共的模式命名，建立抽象，而后直接在抽象的层次上工作。  
>过程提供了这种能力，这也是为什么除了最简单的程序语言外，其他语言都包含定义过程的机制的原因。  

到目前为止（当然时间很短，刚看完第一章），
lisp真正让我惊艳的地方就是可以将过程作为参数传递和返回。   
就1.3.1小节来说，刚开始其实没有看明白lisp是怎样将过程作为参数传递的，
或者说没有看出来有什么这样写的必要。  
当时程序也并没有看太明白，毕竟lisp里如果不看上下文，完全区分不了过程和变量。
虽然lisp好像并不区分这个，但看程序总得区分函数和变量才好理解。  
而且看到过程和其他参数排在一起，
也总觉得是将后面的变量作为参数计算完了再将结果提供给外层的函数……真是年轻。   
一直到1.3.3节，通过区间折半寻找方程的根，才猛然醒悟这里其实是将过程整个传过去了，而不是将计算结果传过去。  
同时lambda表示过程的写法也非常有意思，应该说省了define不少功夫。    

##抽象
这章最后一个部分，没有讲解lisp语言的实现技巧，而是描述了lisp的思路。  
从开头看到现在，我感觉到的lisp核心确实是抽象：从数学中抽象出底层简单的规则，抽象出运算符，抽象出过程，并能将所有抽象级别当做参数。  
由书中原话来说，
>lisp……给了过程完全的第一级状态……由此获得的描述能力是及其惊人的。  

难道既像图灵机又像自然语言的特性来自于过程的第一级状态？
我不确定，反正书里注释各种“在后面的章节会有详细展开”，希望看到后面能对这个问题有更深的认识。
_________
<html>
<del>lisp是最好的语言!（<ゝω・） </del>
<html>
