---
date: 21:27 2015/3/12
title: SICP第一章笔记
layout: post
tag:
  - SICP
  - lisp
---

2015.03.12  
开始读SICP了嗯。  
虽然只看了第一章但是函数式编程真是奇妙。  
已经感受到了lisp的神奇之处了。
  

2015.04.23   
回头看看一个多月前写的东西决定还是重新整理丰富一下比较好……  
有一些是书中内容的整理，有一些是自己的想法。  

---

###程序

>每一种强力的语言都提供了三种机制：

> - *基本表达形式* ，用于表示语言所关心的最简单的个体  
> - *组合的方法*，通过它们可以从简单的东西出发构造复杂的元素  
> - *抽象的方法*，通过它们可以为复合对象命名，并将它们当做单元去操作  

> 程序设计中需要处理两类要素：过程和数据（实际上并不严格区分）  
> 数据是我们希望去操作的“东西”，
> 而过程是有关操作这些数据的规则的描述。  
> 这样，扔和强有力的设计语言都必须能表述基本的数据和基本的过程，
> 以及对过程和数据抽象和组合的方法  

到第一章结束为止，书中给出的Lisp规则都非常简单。  
这意味着本章展示重点的正是如何从简单的规则出发搭建起一个庞然大物，
并以此展示*组合*和*抽象*在程序设计中的意义。  
事实上，平面几何以五大公理为根基，
构造出[生命游戏](http://zh.wikipedia.org/wiki/生命游戏 "生命游戏")
的元胞自动机的规则也不过寥寥数语。
计算机本来就是以图灵机的简单规则构建。  
这么说来，从*组合*和*抽象*开始解释计算机程序再好不过了。  


###表达式  

scheme使用前缀表达式，如：  
```
(+ (* 3 5) (- 10 6))
```  
很少见的写法，不过显然对于计算机（解释器）来说这么写很方便，
而且不容易引起歧义。还很容易构造表达式树。  

###define

>define是最简单的抽象方法。  

定义变量：   
```
	(define pi 3.141159)    
```	  
定义过程：  
```
	(define (square x) (* x x))  
```

###条件表达式   
cond和if。<html><del>居然</del></html>并没有什么奇特的地方。

```
(define (abs x)
	(cond ((> x 0) x)
		  ((= x 0) 0)
		  ((< x 0) (-x))))

(define (abs x)
	(if (< x 0)
		(-x)
		x))
```
		
### 逻辑复合运算符
仍然是前缀表达式写法。  
不禁想起了<html><del>天国的</del></html>logo语言。  
刚开始学C的时候某老师似乎就说过logo的逻辑运算前缀写法比较奇葩，
一般都是中缀。  
当时并不以为意，最近才看到原来logo是lisp的一种方言。  
<html>
<del>从那么小开始就接触函数式编程的我如今找不到工作怎么想都是世界的错</del>
<html>  

```
(and (> x 5) (< x 10))

(or (> x y) (= x y))

```

### 过程作为黑箱抽象
>过程定义应该能隐藏一些细节。
>用户在使用一个过程时应该不需要去弄清如何实现。   

黑箱，只能看见接口，看不见内部结构。
这也是现代软件工程的普遍要求。  
实现黑箱的一个重要部分是处理局部变量和作用域的问题。
然而并没有细说。  

###过程作为参数/作为返回值
```
(define (sum term a next b)
	(if (> a b)
		0
		(+	(term a)
			(sum term (next a) next b))))

(define (inc n) (+ n 1))

(define (cube n) (* n n n))

(define (sum-cubes a b)
	(sum cube a inc b)

(sum-cube 1 10)
55
```
过程inc过程就是简单的自增，cube则是单纯计算立方。  
而过程sum-cubes将cube作为参数term，inc作为参数next传给了sum。  
可以看到sum中累加了term处理a得到的值，
并用inc作为a在递归过程中变化的规则。  
可以说sum-cubes 是sum的一个实例，
实例化的部分就是*累加值的计算规则*和*自变量递进的计算规则*。  
这两个规则就是sum接收到的两个过程，cube和inc  
当然，sum-cubes这个实例同样是过程，而不是表达式或数值。  

### lamda构造过程
如上例中sum-cubes可以写作
```
(define (sum-cubes a b)
	(sum (lambda (x) (* x x x)) a (lambda (x) (+ x 1)) b))
```
即直接用(lambda (x) (+ x 1))来代替inc。  
也就是说lambda可以直接构造过程。  
顺便，lambda构造的过程可用于组合式的运算符，如：
```
((lambda (x y z) (+ x y (square z))) 1 2 3)
12
```
仍然是前缀表达式结果。  

另外注意到最开始提出的
>并不严格区分过程和数据

就上面的sum过程来看，仅看接口无法分辨term是过程还是数据。  
我们有理由相信，数据和过程是基于相似的过程来处理的。  

---

<html>
<del>lisp是最好的语言!（<ゝω・） </del>
<html>
