---
date: 21:27 2015/3/12
title: SICP第一章笔记
layout: post
tag:
  - SICP
  - lisp
---

开始读SICP了嗯。  
虽然只看了第一章但是函数式编程真是奇妙。  
已经感受到了lisp的神奇之处了。  

##环境与组合式
>实际上，构造一个复杂的程序，也就是为了去一步步地创建出越来越复杂的计算性对象。
>解释器使这种逐步的程序构造过程变得非常方便，因为我们可以通过一系列交互式动作，逐步创建起所需要的名字-对象关联。
>这种特征鼓励人们采用递增的方式去开发和调试程序。
>在很大程度上，这一情况也处于另一个事实，那就是，一个Lisp程序通常总是由一大批相对简单的过程组成的。    
>应该看到，我们可以将值与符号关联，而后又能提取处这些值，这意味着解释器必须维护某种存储能力，以便保持有关的名字-值对偶的轨迹。
>这种存储被称为环境。

lisp给我最大的冲击就是他的规则。Lisp的语法非常简单，
好像是在鼓励使用者自己从头实现包括乘除和乘方开方在内的表达式和函数，
甚至有种想只给加号，让使用者从减号开始从头定义整个数学规则的感觉。  
事实上，这一节的示例代码正是在实现平方和绝对值。   
从学习的角度来说，lisp给我一种图灵机的感觉：
仅仅给出最简单最基本但是在数学上完备的规则，
但是又能从简陋的规则上一点一点构建起庞大的运算法则。   
可是看到后来又发现，
define实在太强大（或者说除了define和lambda等等使用者几乎没有其他可以玩的花样了），
以至于简直可以把lisp代码写的比任何一种编程语言都像自然语言。  
简直辩证统一……

##将过程作为参数
>人们对于功能强大的程序设计语言有一个必然要求，
就是能为公共的模式命名，建立抽象，而后直接在抽象的层次上工作。  
>过程提供了这种能力，这也是为什么除了最简单的程序语言外，其他语言都包含定义过程的机制的原因。  

到目前为止（当然时间很短，刚看完第一章），
lisp真正让我惊艳的地方就是可以将过程作为参数传递和返回。   
就1.3.1小节来说，刚开始其实没有看明白lisp是怎样将过程作为参数传递的，
或者说没有看出来有什么这样写的必要。  
当时程序也并没有看太明白，毕竟lisp里如果不看上下文，完全区分不了过程和变量。
虽然lisp好像并不区分这个，但看程序总得区分函数和变量才好理解。  
而且看到过程和其他参数排在一起，
也总觉得是将后面的变量作为参数计算完了再将结果提供给外层的函数……真是年轻。   
一直到1.3.3节，通过区间折半寻找方程的根，才猛然醒悟这里其实是将过程整个传过去了，而不是将计算结果传过去。  
同时lambda表示过程的写法也非常有意思，应该说省了define不少功夫。    

##抽象
这章最后一个部分，没有讲解lisp语言的实现技巧，而是描述了lisp的思路。  
从开头看到现在，我感觉到的lisp核心确实是抽象：从数学中抽象出底层简单的规则，抽象出运算符，抽象出过程，并能将所有抽象级别当做参数。  
由书中原话来说，
>lisp……给了过程完全的第一级状态……由此获得的描述能力是及其惊人的。  

难道既像图灵机又像自然语言的特性来自于过程的第一级状态？
我不确定，反正书里注释各种“在后面的章节会有详细展开”，希望看到后面能对这个问题有更深的认识。
_________
<html>
<del>lisp是最好的语言!（<ゝω・） </del>
<html>
