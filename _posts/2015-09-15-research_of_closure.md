---
date: 14:14 2015/09/15
title: 抽象代数与函数式编程中的“闭包”
layout: post
tag:
  - 编程
  - 函数式编程
  - 闭包
  - 抽象代数
---

最近在蹭编译原理。
开始讲了一点抽象代数（貌似）的内容，其中有闭包。  

---

闭包的概念很早就听说过，据说是javascript面试必问内容之一。
最近写的ruby和python里似乎也有类似的内容，之前也有简单接触过，不过因为工作中很少用到所以没有深究。  
和函数式编程也有一点关系，不过看sicp的时候倒是没什么印象。  
这次在抽象代数的领域再听到，看来是有必要研究一下了。  

---

先说结论：  
**看起来这两个领域是没什么关系的**  

来源于SICP的2.2节：
> 术语“闭包”来自抽象代数。
> 在抽象代数里，一集元素称为在某个运算（操作）下封闭，如果将该运算应用于这一集合中的元素，产出的仍然是该集合里的元素。  
> 然而Lisp社团（很不幸）还用术语“闭包”描述另一个于此*毫不相干*的概念：闭包也是一种为表示带有自由变量的过程而用的实现技术。

……  
对此我只能说真遗憾，还以为有什么大新闻。  

---

先说抽象代数中的闭包。  

在编译原理课程当中，最开始会讲到字符集等等。  

前一节说到SICP中对封闭的定义：
> 如果将某个运算c应用于集合S中的元素，产出的仍然是集合S中的元素，则称该集合S在运算c下封闭

以此为基础，
> *包含*指定集合的满足在某个运算下*闭合*的*最小集合* 

大概类似于“S是s在运算c下的闭包”这样的表述。  

---

函数式编程中的闭包要有趣得多。  

使用SICP中Scheme的语法，  

```
(define (f x)
  (lambda (y) (+ x y)))
```

这里定义了一个函数f(x), 有意思的是这里的返回值仍然是一个函数，
比如f(1)返回的是  

```
(lambda (y) (+ 1 y))
```

不得不说初看SICP时这里卡了好久看不懂。  

由于Scheme解释时是完全替换的方式，如果给出这样一个表达式：  

```
((f 1) 2)
```

会解释成  

```
((lambda (y) (+ 1 y)) 2)
```

进一步，lambda函数接收了2作为参数，将其代入y:

```
((+ 1 2))
```

似乎好自然的样子，并没有什么不对……  

问题在于正常语言的解释器的工作原理并不是对字符串做简单替换。  

> 如果按照一般语言的角度来看，执行(f 1)之后，f函数就结束了，
> 而x（这里被赋值为1）是f的私有变量（绑定于f）。
> 那么程序设计语言的设计者就有两种选择：  
> 第一，在函数超出其作用域后立即销毁其绑定变量，
> 如果是这样的话，((f 1) 2) 是无法得出结果的，
> 因为在外层的f运算结束后，存放数值“1”的变量就被释放了，
> 所以匿名函数无法得到其自由变量x的值；  
> 显然scheme的设计者做了第二种选择：
> 如果一个函数返回另一个函数，而被返回函数又需要外层函数的变量时，
> 不会立即释放这个变量，而是允许被返回的函数引用这些变量。  

支持这种机制的语言称为支持闭包机制，而这个内部函数连同其自由变量就形成了一个闭包。

---

TODO: Ruby广泛地吸收了函数式编程的特性，对闭包当然也支持。
用Ruby实现一下闭包，看看是否有什么实用价值。

---

SICP 2.2节，层次性数据和闭包性质，第一次提到了闭包。  
如同上面所说，这里使用的是抽象代数中的闭包概念。  

> 我们可以建立起元素本身也是序对(cons, construct)的序对，这就是表结构得以作为一种表示工具的根本基础。
> 我们将这种能力称为cons的*闭包性质*。  
> ……闭包性质是任何一种组合功能的威力的关键要素，因为它是我们能够建立起*层次性*的结构，
> 这种结构由一些部分构成，而其中的各个部分又是它们的部分构成，并且可以如此继续下去。

这里说的闭包是指scheme用以组合数据的方法cons具有闭包性质，即cons组合出的结构也可以继续用cons组合下去。  
这种简单优雅的结构在数学上似乎理所应当，但各种程序语言实现起来总会有各种各样的障碍，
比如2.2节注释所说Fortran, Basic, Pascal, C等等都没有完全实现这一性质。  
不过现在流行的Ruby, Python等似乎都可以？Ruby中Array的元素可以是很多数据类型混在一起，包括Array。  
Array的一些与高阶函数有关的方法，比如映射(map)，归约(reduce)，用起来都非常令人开心。  

---