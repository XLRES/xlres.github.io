---
date: 14:14 2015/09/15
title: 抽象代数与函数式编程中的“闭包”
layout: post
tag:
  - 编程
  - 函数式编程
  - 闭包
  - 抽象代数
---

最近在蹭编译原理。
开始讲了一点抽象代数（貌似）的内容，其中有闭包。  

闭包的概念很早就听说过，据说是javascript面试必问内容之一。
最近写的ruby和python里似乎也有类似的内容，之前也有简单接触过，和函数式编程也有一点关系，不过看sicp的时候倒是没什么印象。  
这次在抽象代数的领域再听到，看来是有必要研究一下了。  

---

先说结论：  
**看起来这两个领域是没什么关系的**  

来源于SICP的2.2节：
> 术语“闭包”来自抽象代数。
> 在抽象代数里，一集元素称为在某个运算（操作）下封闭，如果将该运算应用于这一集合中的元素，产出的仍然是该集合里的元素。  
> 然而Lisp社团（很不幸）还用术语“闭包”描述另一个于此*毫不相干*的概念：闭包也是一种为表示带有自由变量的过程而用的实现技术。

……  
对此我只能说真遗憾，还以为有什么大新闻。  

---

先说抽象代数中的闭包。  

在编译原理课程当中，最开始会讲到字符集等等。  

前一节说到SICP中对封闭的定义：
> 如果将某个运算c应用于集合S中的元素，产出的仍然是集合S中的元素，则称该集合S在运算c下封闭

以此为基础，
> *包含*指定集合的满足在某个运算下*闭合*的*最小集合* 

大概类似于“S是s在运算c下的闭包”这样的表述。  

---

函数式编程中的闭包要有趣得多。  

使用SICP中Scheme的语法，  

```
(define (f x)
  (lambda (y) (+ x y)))
```

这里定义了一个函数f(x), 有意思的是这里的返回值仍然是一个函数，
比如f(1)返回的是  

```
(lambda (y) (+ 1 y))
```

不得不说初看SICP时这里卡了好久看不懂。  

由于Scheme解释时是完全替换的方式，如果给出这样一个表达式：  

```
((f 1) 2)
```

会解释成  

```
((lambda (y) (+ 1 y)) 2)
```

进一步，lambda函数接收了2作为参数，将其代入y:

```
((+ 1 2))
```

似乎好自然的样子，并没有什么不对……  

问题在于正常语言的解释器的工作原理并不是对字符串做简单替换。  

> 如果按照一般语言的角度来看，执行(f 1)之后，f函数就结束了，
> 而x（这里被赋值为1）是f的私有变量（绑定于f）。
> 那么程序设计语言的设计者就有两种选择：  
> 第一，在函数超出其作用域后立即销毁其绑定变量，
> 如果是这样的话，((f 1) 2) 是无法得出结果的，
> 因为在外层的f运算结束后，存放数值“1”的变量就被释放了，
> 所以匿名函数无法得到其自由变量x的值；  
> 显然scheme的设计者做了第二种选择：
> 如果一个函数返回另一个函数，而被返回函数又需要外层函数的变量时，
> 不会立即释放这个变量，而是允许被返回的函数引用这些变量。  

支持这种机制的语言称为支持闭包机制，而这个内部函数连同其自由变量就形成了一个闭包。

---

TODO: Ruby广泛地吸收了函数式编程的特性，对闭包当然也支持。
用Ruby实现一下闭包，看看是否有什么实用价值。

---

TODO: 重温SICP中关于闭包的说明。

---